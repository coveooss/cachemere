<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cachemere: Implementing Custom Policies</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cachemere
   </div>
   <div id="projectbrief">Modular Caching Library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Implementing Custom Policies </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page is meant to guide you through the implementation of custom policies. </p>
<h1><a class="anchor" id="autotoc_md9"></a>
Shared Characteristics</h1>
<h2><a class="anchor" id="autotoc_md10"></a>
Construction Requirements</h2>
<p>Insertion and eviction policies <em>must</em> be <a href="http://www.cplusplus.com/reference/type_traits/is_default_constructible/">default-constructible</a>. The constraint policy may take parameters, these parameters will be forwarded to the policy from the cache constructor. </p>
<h2><a class="anchor" id="autotoc_md11"></a>
Template Parameters</h2>
<p>Cache policies are templates, which must take exactly three template parameters: <code>typename Key</code>, <code>typename KeyHash</code>, and <code>typename Value</code>. If a policy needs additional parameterization, <code><a class="el" href="structcachemere_1_1policy_1_1bind.html" title="Binds a Policy&lt;K, KH, V, Args...&gt; template to a Policy&lt;K, KH, V&gt; template to be used with the cache.">cachemere::policy::bind</a></code> can be used for partial specialization, allowing use with the cache. </p>
<h2><a class="anchor" id="autotoc_md12"></a>
Event Handlers</h2>
<p>The policies <em>may</em> define the following event handlers to be notified of changes in the cache. These handlers do not all need to be implemented; a policy only needs to define the handlers that are relevant to its implementation. The cache will detect available handlers on its policies at compile-time, and will only call those that are defined.</p><ul>
<li><p class="startli"><code>void on_insert(K&amp; key, cachemere::detail::Item&lt;V&gt;&amp; item)</code></p>
<p class="startli">Called immediately after a successful insertion in cache.</p>
</li>
<li><p class="startli"><code>void on_update(K&amp; key, cachemere::detail::Item&lt;V&gt;&amp; item)</code></p>
<p class="startli">Called immediately after an insertion of an item that was already in cache (which has the effect of updating its value).</p>
</li>
<li><p class="startli"><code>void on_cache_hit(K&amp; key, cachemere::detail::Item&lt;V&gt;&amp; item)</code></p>
<p class="startli">Called immediately after a cache hit (a successful call to <code><a class="el" href="classcachemere_1_1Cache.html#af4ea31ad36af4973ecbe0a610612cee1" title="Find a given key in cache returning the associated value when it exists.">cachemere::Cache::find</a></code>).</p>
</li>
<li><p class="startli"><code>template&lt;typename KeyType&gt; void on_cache_miss(const KeyView&amp; key)</code></p>
<p class="startli">Where <code>KeyType</code> is a type that hashes to the same value as its corresponding <code>Key</code> using <code>KeyHash</code>. Called immediately after a cache miss (an unsuccessful call to <code><a class="el" href="classcachemere_1_1Cache.html#af4ea31ad36af4973ecbe0a610612cee1" title="Find a given key in cache returning the associated value when it exists.">cachemere::Cache::find</a></code>).</p>
</li>
<li><p class="startli"><code>void on_evict(K&amp; key)</code></p>
<p class="startli">Called immediately <em>before</em> dropping the provided key from the cache. The call is done this way to allow policies to keep references to cached items instead of copies.</p>
</li>
</ul>
<h2><a class="anchor" id="autotoc_md13"></a>
Lifetime Requirements</h2>
<p>Policies can safely keep references to object <b>keys</b> given that they properly drop all references to that key upon receiving an <code>on_evict</code> event.</p>
<p>Policies can safely keep references to object <b>values</b> given that they properly drop all references to that value upon receiving an <code>on_evict</code> event. In addition, policies keeping references to values <b>must</b> swap the held reference with the updated reference when receiving an <code>on_update</code> event.</p>
<dl class="section warning"><dt>Warning</dt><dd>Keeping references to cache-owned keys or values without respecting the constraints above will result in undefined behavior.</dd></dl>
<h2><a class="anchor" id="autotoc_md14"></a>
Concurrency Requirements</h2>
<p>Policies do not need to take any steps to ensure thread-safety. The cache will properly protect policies to ensure no concurrent operations occur.</p>
<h1><a class="anchor" id="autotoc_md15"></a>
Constraint Policy</h1>
<p>In addition to the shared requirements above, a constraint policy must implement the following methods in order to be valid:</p>
<ul>
<li><p class="startli"><code>bool can_add(const Key&amp; key, const Item&lt;Value&gt;&amp; item)</code></p>
<p class="startli">Should return <code>true</code> if the item can be inserted in the cache while still satisfying the constraint. </p><dl class="section note"><dt>Note</dt><dd>Returning <code>true</code> guarantees that the object matching the key will be inserted in cache.</dd></dl>
</li>
<li><p class="startli"><code>bool can_replace(const Key&amp; key, const Item&lt;Value&gt;&amp; old_item, const Item&lt;Value&gt;&amp; new_item)</code></p>
<p class="startli">Should return <code>true</code> if the value associated with <code>key</code> can be changed from <code>old_item</code> to <code>new_item</code> while still satisfying the constraint. </p><dl class="section note"><dt>Note</dt><dd>Returning <code>true</code> guarantees that the object matching the key will be updated.</dd></dl>
</li>
<li><p class="startli"><code>bool is_satisfied()</code></p>
<p class="startli">Should return <code>true</code> if the constraint is currently satisfied. The cache uses this method after a constraint update (e.g. a cache resize) to determine whether items should be evicted to make some room.</p>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md16"></a>
Insertion Policy</h1>
<p>In addition to the shared requirements above, an insertion policy must implement the following methods in order to be valid:</p>
<ul>
<li><p class="startli"><code>bool should_add(const Key&amp; key)</code></p>
<p class="startli">Should return <code>true</code> if the policy allows the specified key to be inserted in cache. </p><dl class="section note"><dt>Note</dt><dd>Returning <code>true</code> guarantees that the object matching the key will be inserted in cache.</dd></dl>
</li>
<li><p class="startli"><code>bool should_replace(const Key&amp; victim, const Key&amp; candidate)</code></p>
<p class="startli">Should return <code>true</code> if the policy states that the candidate should replace the victim in cache. </p><dl class="section note"><dt>Note</dt><dd>Returning <code>true</code> does not guarantee that the object matching the <code>candidate</code> key will be inserted in cache.</dd></dl>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md17"></a>
Eviction Policy</h1>
<p>In addition to the shared requirements above, an eviction policy must implement the following methods in order to be valid:</p>
<ul>
<li><p class="startli"><code>Iterator victim_begin() const</code></p>
<p class="startli">Should return an iterator pointing to the first <em>key</em> that should be evicted from the cache. </p><dl class="section warning"><dt>Warning</dt><dd>Returning a key from this iterator does not guarantee that the item will be evicted. The policy should only rely on event handlers to track which items are currently in cache.</dd></dl>
</li>
<li><p class="startli"><code>Iterator victim_end() const</code></p>
<p class="startli">Should return an end iterator. Used to determine whether victim iteration is complete. </p>
</li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
