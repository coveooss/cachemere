<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cachemere: cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cachemere
   </div>
   <div id="projectbrief">Modular Caching Library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecachemere.html">cachemere</a></li><li class="navelem"><a class="el" href="classcachemere_1_1Cache.html">Cache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classcachemere_1_1Cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread-safe memory-restricted cache.  
 <a href="classcachemere_1_1Cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache_8h_source.html">cache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac341cdb09fcef6a1ff8d0356bd548e46"><td class="memItemLeft" align="right" valign="top"><a id="ac341cdb09fcef6a1ff8d0356bd548e46"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyInsertionPolicy</b> = InsertionPolicy&lt; Key, Value &gt;</td></tr>
<tr class="separator:ac341cdb09fcef6a1ff8d0356bd548e46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14988e00b1d8efa431816f8031f0989"><td class="memItemLeft" align="right" valign="top"><a id="ae14988e00b1d8efa431816f8031f0989"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyEvictionPolicy</b> = EvictionPolicy&lt; Key, Value &gt;</td></tr>
<tr class="separator:ae14988e00b1d8efa431816f8031f0989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242dfc91d0243a7a36ac9fe8e430a702"><td class="memItemLeft" align="right" valign="top"><a id="a242dfc91d0243a7a36ac9fe8e430a702"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyConstraintPolicy</b> = ConstraintPolicy&lt; Key, Value &gt;</td></tr>
<tr class="separator:a242dfc91d0243a7a36ac9fe8e430a702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20e866c6a9be1020390c01c2dda1eaf5"><td class="memItemLeft" align="right" valign="top"><a id="a20e866c6a9be1020390c01c2dda1eaf5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CacheType</b> = <a class="el" href="classcachemere_1_1Cache.html">Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;</td></tr>
<tr class="separator:a20e866c6a9be1020390c01c2dda1eaf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38a0840a55c5c027fdcfe56c4433c7e9"><td class="memItemLeft" align="right" valign="top"><a id="a38a0840a55c5c027fdcfe56c4433c7e9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LockGuard</b> = std::unique_lock&lt; std::recursive_mutex &gt;</td></tr>
<tr class="separator:a38a0840a55c5c027fdcfe56c4433c7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7e58cf1f7e976717e494c2a82930d1a1"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a7e58cf1f7e976717e494c2a82930d1a1"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a7e58cf1f7e976717e494c2a82930d1a1">Cache</a> (Args... args)</td></tr>
<tr class="memdesc:a7e58cf1f7e976717e494c2a82930d1a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple constructor.  <a href="classcachemere_1_1Cache.html#a7e58cf1f7e976717e494c2a82930d1a1">More...</a><br /></td></tr>
<tr class="separator:a7e58cf1f7e976717e494c2a82930d1a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786af0872ad252415e1e8aed77aa116d"><td class="memTemplParams" colspan="2">template&lt;typename C , typename... Args&gt; </td></tr>
<tr class="memitem:a786af0872ad252415e1e8aed77aa116d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a786af0872ad252415e1e8aed77aa116d">Cache</a> (C &amp;collection, std::tuple&lt; Args... &gt; args)</td></tr>
<tr class="memdesc:a786af0872ad252415e1e8aed77aa116d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to initialize the cache with a set of items.  <a href="classcachemere_1_1Cache.html#a786af0872ad252415e1e8aed77aa116d">More...</a><br /></td></tr>
<tr class="separator:a786af0872ad252415e1e8aed77aa116d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42cc91e6cc65f9fc7bea93572e4ba4a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a42cc91e6cc65f9fc7bea93572e4ba4a5">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a42cc91e6cc65f9fc7bea93572e4ba4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given key is stored in the cache.  <a href="classcachemere_1_1Cache.html#a42cc91e6cc65f9fc7bea93572e4ba4a5">More...</a><br /></td></tr>
<tr class="separator:a42cc91e6cc65f9fc7bea93572e4ba4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563b737e0c1e791cf7e0343d545d8437"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a563b737e0c1e791cf7e0343d545d8437">find</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a563b737e0c1e791cf7e0343d545d8437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a given key in cache returning the associated value when it exists.  <a href="classcachemere_1_1Cache.html#a563b737e0c1e791cf7e0343d545d8437">More...</a><br /></td></tr>
<tr class="separator:a563b737e0c1e791cf7e0343d545d8437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6973ebec90fb7f75b8935e4a2c1d76ca"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a6973ebec90fb7f75b8935e4a2c1d76ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a6973ebec90fb7f75b8935e4a2c1d76ca">collect_into</a> (C &amp;container) const</td></tr>
<tr class="memdesc:a6973ebec90fb7f75b8935e4a2c1d76ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the cache contents in the provided container.  <a href="classcachemere_1_1Cache.html#a6973ebec90fb7f75b8935e4a2c1d76ca">More...</a><br /></td></tr>
<tr class="separator:a6973ebec90fb7f75b8935e4a2c1d76ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2cb36c96d61e71dc72352c62114323"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a2b2cb36c96d61e71dc72352c62114323">insert</a> (Key key, Value value)</td></tr>
<tr class="memdesc:a2b2cb36c96d61e71dc72352c62114323"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair in the cache.  <a href="classcachemere_1_1Cache.html#a2b2cb36c96d61e71dc72352c62114323">More...</a><br /></td></tr>
<tr class="separator:a2b2cb36c96d61e71dc72352c62114323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b1d3e571f1489d1a01dd3ae42122e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#aa9b1d3e571f1489d1a01dd3ae42122e8">remove</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:aa9b1d3e571f1489d1a01dd3ae42122e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a key and its value from the cache.  <a href="classcachemere_1_1Cache.html#aa9b1d3e571f1489d1a01dd3ae42122e8">More...</a><br /></td></tr>
<tr class="separator:aa9b1d3e571f1489d1a01dd3ae42122e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b972ae64515d9073ada458ab439ae6"><td class="memItemLeft" align="right" valign="top"><a id="a95b972ae64515d9073ada458ab439ae6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a95b972ae64515d9073ada458ab439ae6">clear</a> ()</td></tr>
<tr class="memdesc:a95b972ae64515d9073ada458ab439ae6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the cache contents. <br /></td></tr>
<tr class="separator:a95b972ae64515d9073ada458ab439ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a288411b8f38e4c7b507805e9d04edf24"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a288411b8f38e4c7b507805e9d04edf24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a288411b8f38e4c7b507805e9d04edf24">retain</a> (P predicate_fn)</td></tr>
<tr class="memdesc:a288411b8f38e4c7b507805e9d04edf24"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retain all objects matching a predicate.  <a href="classcachemere_1_1Cache.html#a288411b8f38e4c7b507805e9d04edf24">More...</a><br /></td></tr>
<tr class="separator:a288411b8f38e4c7b507805e9d04edf24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac712099d550ec81fc9ff268c5ac3d092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ac712099d550ec81fc9ff268c5ac3d092">swap</a> (<a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;other)</td></tr>
<tr class="memdesc:ac712099d550ec81fc9ff268c5ac3d092"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the current cache with another cache of the same type.  <a href="classcachemere_1_1Cache.html#ac712099d550ec81fc9ff268c5ac3d092">More...</a><br /></td></tr>
<tr class="separator:ac712099d550ec81fc9ff268c5ac3d092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e56ba870329889bb7a1e30415be2f48"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a2e56ba870329889bb7a1e30415be2f48">number_of_items</a> () const</td></tr>
<tr class="memdesc:a2e56ba870329889bb7a1e30415be2f48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently stored in the cache.  <a href="classcachemere_1_1Cache.html#a2e56ba870329889bb7a1e30415be2f48">More...</a><br /></td></tr>
<tr class="separator:a2e56ba870329889bb7a1e30415be2f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae08f40df4f0a448c6659a156195fb5ed"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ae08f40df4f0a448c6659a156195fb5ed"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ae08f40df4f0a448c6659a156195fb5ed">update_constraint</a> (Args... args)</td></tr>
<tr class="memdesc:ae08f40df4f0a448c6659a156195fb5ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cache constraint.  <a href="classcachemere_1_1Cache.html#ae08f40df4f0a448c6659a156195fb5ed">More...</a><br /></td></tr>
<tr class="separator:ae08f40df4f0a448c6659a156195fb5ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a540e40f335e2f83e91495ae6d10ef7d9"><td class="memItemLeft" align="right" valign="top"><a id="a540e40f335e2f83e91495ae6d10ef7d9"></a>
MyInsertionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a540e40f335e2f83e91495ae6d10ef7d9">insertion_policy</a> ()</td></tr>
<tr class="memdesc:a540e40f335e2f83e91495ae6d10ef7d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the insertion policy used by the cache. <br /></td></tr>
<tr class="separator:a540e40f335e2f83e91495ae6d10ef7d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76d834c7d7178ef9f57f500f658cb9a8"><td class="memItemLeft" align="right" valign="top"><a id="a76d834c7d7178ef9f57f500f658cb9a8"></a>
const MyInsertionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a76d834c7d7178ef9f57f500f658cb9a8">insertion_policy</a> () const</td></tr>
<tr class="memdesc:a76d834c7d7178ef9f57f500f658cb9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the insertion policy used by the cache. <br /></td></tr>
<tr class="separator:a76d834c7d7178ef9f57f500f658cb9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9367163f148353f47e68aabc320e17c"><td class="memItemLeft" align="right" valign="top"><a id="ae9367163f148353f47e68aabc320e17c"></a>
MyEvictionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ae9367163f148353f47e68aabc320e17c">eviction_policy</a> ()</td></tr>
<tr class="memdesc:ae9367163f148353f47e68aabc320e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the eviction policy used by the cache. <br /></td></tr>
<tr class="separator:ae9367163f148353f47e68aabc320e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcd871ae6600bea0fdd8bafd7ea87a"><td class="memItemLeft" align="right" valign="top"><a id="a8bfcd871ae6600bea0fdd8bafd7ea87a"></a>
const MyEvictionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a8bfcd871ae6600bea0fdd8bafd7ea87a">eviction_policy</a> () const</td></tr>
<tr class="memdesc:a8bfcd871ae6600bea0fdd8bafd7ea87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the eviction policy used by the cache. <br /></td></tr>
<tr class="separator:a8bfcd871ae6600bea0fdd8bafd7ea87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c30daecfa8dc9e011de59891c87d8"><td class="memItemLeft" align="right" valign="top"><a id="ab22c30daecfa8dc9e011de59891c87d8"></a>
MyConstraintPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ab22c30daecfa8dc9e011de59891c87d8">constraint_policy</a> ()</td></tr>
<tr class="memdesc:ab22c30daecfa8dc9e011de59891c87d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the constraint policy used by the cache. <br /></td></tr>
<tr class="separator:ab22c30daecfa8dc9e011de59891c87d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9e3dd71e1d14a876c6b4118d5d9398"><td class="memItemLeft" align="right" valign="top"><a id="afb9e3dd71e1d14a876c6b4118d5d9398"></a>
const MyConstraintPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#afb9e3dd71e1d14a876c6b4118d5d9398">constraint_policy</a> () const</td></tr>
<tr class="memdesc:afb9e3dd71e1d14a876c6b4118d5d9398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the constraint policy used by the cache. <br /></td></tr>
<tr class="separator:afb9e3dd71e1d14a876c6b4118d5d9398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80fef5d0a61973e6c21b9c720a72f0e0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a80fef5d0a61973e6c21b9c720a72f0e0">hit_rate</a> () const</td></tr>
<tr class="memdesc:a80fef5d0a61973e6c21b9c720a72f0e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running hit rate of the cache.  <a href="classcachemere_1_1Cache.html#a80fef5d0a61973e6c21b9c720a72f0e0">More...</a><br /></td></tr>
<tr class="separator:a80fef5d0a61973e6c21b9c720a72f0e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da0df2c6bfc1cb05dbc622414d42318"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a0da0df2c6bfc1cb05dbc622414d42318">byte_hit_rate</a> () const</td></tr>
<tr class="memdesc:a0da0df2c6bfc1cb05dbc622414d42318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running byte hit rate of the cache, in bytes.  <a href="classcachemere_1_1Cache.html#a0da0df2c6bfc1cb05dbc622414d42318">More...</a><br /></td></tr>
<tr class="separator:a0da0df2c6bfc1cb05dbc622414d42318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a825ab53518ac0a3956b1552f8a8f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a58a825ab53518ac0a3956b1552f8a8f1">statistics_window_size</a> () const</td></tr>
<tr class="memdesc:a58a825ab53518ac0a3956b1552f8a8f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the sliding window used for computing statistics.  <a href="classcachemere_1_1Cache.html#a58a825ab53518ac0a3956b1552f8a8f1">More...</a><br /></td></tr>
<tr class="separator:a58a825ab53518ac0a3956b1552f8a8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f19566b05307dd2e5f2f7ff9c200aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a70f19566b05307dd2e5f2f7ff9c200aa">statistics_window_size</a> (uint32_t window_size)</td></tr>
<tr class="memdesc:a70f19566b05307dd2e5f2f7ff9c200aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the sliding window used for computing statistics.  <a href="classcachemere_1_1Cache.html#a70f19566b05307dd2e5f2f7ff9c200aa">More...</a><br /></td></tr>
<tr class="separator:a70f19566b05307dd2e5f2f7ff9c200aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01c80f32d5f85194e96d661726139814"><td class="memTemplParams" colspan="2"><a id="a01c80f32d5f85194e96d661726139814"></a>
template&lt;typename Coll , typename... Args&gt; </td></tr>
<tr class="memitem:a01c80f32d5f85194e96d661726139814"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cache</b> (Coll &amp;collection, std::tuple&lt; Args... &gt; args)</td></tr>
<tr class="separator:a01c80f32d5f85194e96d661726139814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9232b3b8b7725412c6f591f3425a0665"><td class="memTemplParams" colspan="2"><a id="a9232b3b8b7725412c6f591f3425a0665"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a9232b3b8b7725412c6f591f3425a0665"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collect_into</b> (Container &amp;container) const</td></tr>
<tr class="separator:a9232b3b8b7725412c6f591f3425a0665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea10280b0bc40cd396d8775cc987622"><td class="memTemplParams" colspan="2"><a id="a9ea10280b0bc40cd396d8775cc987622"></a>
template&lt;class Coll &gt; </td></tr>
<tr class="memitem:a9ea10280b0bc40cd396d8775cc987622"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>import</b> (Coll &amp;collection)</td></tr>
<tr class="separator:a9ea10280b0bc40cd396d8775cc987622"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a640abd43b47e11fcceb738f3e105c468"><td class="memItemLeft" align="right" valign="top"><a id="a640abd43b47e11fcceb738f3e105c468"></a>
LockGuard&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> () const</td></tr>
<tr class="separator:a640abd43b47e11fcceb738f3e105c468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a43f24b5bac010c4ab393b8523213b9"><td class="memItemLeft" align="right" valign="top"><a id="a7a43f24b5bac010c4ab393b8523213b9"></a>
LockGuard&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> (std::defer_lock_t defer_lock_tag) const</td></tr>
<tr class="separator:a7a43f24b5bac010c4ab393b8523213b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7f419d3b4a3392189af52c34e3957e5"><td class="memItemLeft" align="right" valign="top"><a id="aa7f419d3b4a3392189af52c34e3957e5"></a>
std::pair&lt; LockGuard, LockGuard &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lock_pair</b> (<a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;other) const</td></tr>
<tr class="separator:aa7f419d3b4a3392189af52c34e3957e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c49346cfdc61f82f80292b54b290c8"><td class="memTemplParams" colspan="2"><a id="ae0c49346cfdc61f82f80292b54b290c8"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:ae0c49346cfdc61f82f80292b54b290c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>import</b> (C &amp;collection)</td></tr>
<tr class="separator:ae0c49346cfdc61f82f80292b54b290c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue = measurement::Size&lt;Value&gt;, typename MeasureKey = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt;<br />
class cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;</h3>

<p>Thread-safe memory-restricted cache. </p>
<p>This class keeps the inserted items alive, and it handles the bulk of the Insert/Evict logic while respecting the size constraints.</p>
<p>Some logic is delegated to the insertion and eviction policies. For details, see the <a class="el" href="index.html">Main Page</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the key used for retrieving items. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the items stored in the cache. </td></tr>
    <tr><td class="paramname">InsertionPolicy</td><td>A template parameterized by <code>Key</code> and <code>Value</code> implementing the insertion policy interface. </td></tr>
    <tr><td class="paramname">EvictionPolicy</td><td>A template parameterized by <code>Key</code> and <code>Value</code> implementing the eviction policy interface. </td></tr>
    <tr><td class="paramname">ConstraintPolicy</td><td>A template parameterized by <code>Key</code> and <code>Value</code> implementing the constraint policy interface. </td></tr>
    <tr><td class="paramname">MeasureValue</td><td>A functor returning the size of a cache value. </td></tr>
    <tr><td class="paramname">MeasureKey</td><td>A functor returning the size of a cache key. </td></tr>
    <tr><td class="paramname">ThreadSafe</td><td>Whether to enable locking. When true, all cache operations will be protected by a lock. <code>true</code> by default. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7e58cf1f7e976717e494c2a82930d1a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e58cf1f7e976717e494c2a82930d1a1">&#9670;&nbsp;</a></span>Cache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue , typename MeasureKey , bool ThreadSafe&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::<a class="el" href="classcachemere_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the constraint policy constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a786af0872ad252415e1e8aed77aa116d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786af0872ad252415e1e8aed77aa116d">&#9670;&nbsp;</a></span>Cache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<div class="memtemplate">
template&lt;typename C , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::<a class="el" href="classcachemere_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Args... &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to initialize the cache with a set of items. </p>
<p>Will insert items in order in the cache as long as the constraint is satisfied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection to use to initialize the cache - must be a collection of pairs. </td></tr>
    <tr><td class="paramname">args</td><td>Tuple of arguments to forward to the constraint policy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Items that are imported from the collection are moved out of the container and left in an unspecified state. The container itself can be reused after clearing it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0da0df2c6bfc1cb05dbc622414d42318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da0df2c6bfc1cb05dbc622414d42318">&#9670;&nbsp;</a></span>byte_hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::byte_hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running byte hit rate of the cache, in bytes. </p>
<p>The byte hit rate represents the average amount of data saved by cache accesses. This is a very useful metric in applications where item load times scale linearly with item size, for instance in a web server. </p><dl class="section return"><dt>Returns</dt><dd>The byte hit rate, in bytes. </dd></dl>

</div>
</div>
<a id="a6973ebec90fb7f75b8935e4a2c1d76ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6973ebec90fb7f75b8935e4a2c1d76ca">&#9670;&nbsp;</a></span>collect_into()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::collect_into </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the cache contents in the provided container. </p>
<p>The container should conform to either of the STL's interfaces for associative containers or for sequence containers. Uses <code>emplace_back</code> for sequence containers, and <code>emplace</code> for associative containers. If the provided container has <code>size()</code> and <code>reserve()</code> methods, <code>collect_into</code> will reserve the appropriate amount of space in the container before inserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container in which to insert the items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a42cc91e6cc65f9fc7bea93572e4ba4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42cc91e6cc65f9fc7bea93572e4ba4a5">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given key is stored in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose presence to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key is in cache. </dd></dl>

</div>
</div>
<a id="a563b737e0c1e791cf7e0343d545d8437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563b737e0c1e791cf7e0343d545d8437">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; V &gt; <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a given key in cache returning the associated value when it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if <code>key</code> is in cache, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a80fef5d0a61973e6c21b9c720a72f0e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80fef5d0a61973e6c21b9c720a72f0e0">&#9670;&nbsp;</a></span>hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running hit rate of the cache. </p>
<p>The hit rate is computed using a sliding window determined by the sliding window size passed to the constructor. </p><dl class="section return"><dt>Returns</dt><dd>The hit rate, as a fraction. </dd></dl>

</div>
</div>
<a id="a2b2cb36c96d61e71dc72352c62114323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2cb36c96d61e71dc72352c62114323">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a key/value pair in the cache. </p>
<p>If the key is new, the key/value pair will be inserted. If the key already exists, the provided value will overwrite the previous one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to associate with the value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the item was inserted in cache. </dd></dl>

</div>
</div>
<a id="a2e56ba870329889bb7a1e30415be2f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e56ba870329889bb7a1e30415be2f48">&#9670;&nbsp;</a></span>number_of_items()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::number_of_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently stored in the cache. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method acquires a mutual exclusion lock to secure the item count. Calling this excessively while the cache is under contention will be detrimental to performance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>How many items are in cache. </dd></dl>

</div>
</div>
<a id="aa9b1d3e571f1489d1a01dd3ae42122e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b1d3e571f1489d1a01dd3ae42122e8">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, template&lt; class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a key and its value from the cache. </p>
<p>If the key is not present in cache, no operation is taken. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove from the cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key was present in cache. </dd></dl>

</div>
</div>
<a id="a288411b8f38e4c7b507805e9d04edf24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a288411b8f38e4c7b507805e9d04edf24">&#9670;&nbsp;</a></span>retain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::retain </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>predicate_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retain all objects matching a predicate. </p>
<p>Removes all items for which <code>predicate_fn</code> returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate_fn</td><td>The predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The type of the predicate function. The predicate should have the signature <code>bool fn(const Key&amp; key, const Value&amp; value)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58a825ab53518ac0a3956b1552f8a8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a825ab53518ac0a3956b1552f8a8f1">&#9670;&nbsp;</a></span>statistics_window_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::statistics_window_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the sliding window used for computing statistics. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the statistics sliding window. </dd></dl>

</div>
</div>
<a id="a70f19566b05307dd2e5f2f7ff9c200aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f19566b05307dd2e5f2f7ff9c200aa">&#9670;&nbsp;</a></span>statistics_window_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::statistics_window_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>window_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the sliding window used for computing statistics. </p>
<dl class="section warning"><dt>Warning</dt><dd>This will reset the access log, so cache accesses made prior to calling this will not be counted in the statistics. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_size</td><td>The desired statistics window size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac712099d550ec81fc9ff268c5ac3d092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac712099d550ec81fc9ff268c5ac3d092">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the current cache with another cache of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The cache to swap this instance with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae08f40df4f0a448c6659a156195fb5ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae08f40df4f0a448c6659a156195fb5ed">&#9670;&nbsp;</a></span>update_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, template&lt; class, class &gt; class C, class SV , class SK , bool TS&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, TS &gt;::update_constraint </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the cache constraint. </p>
<p>Forwards the update to the constraint and evicts items from the cache until the constraint is satisfied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the <code>Constraint::update()</code> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cachemere/<a class="el" href="cache_8h_source.html">cache.h</a></li>
<li>include/cachemere/<a class="el" href="cache_8hpp_source.html">cache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
