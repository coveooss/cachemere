<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cachemere: cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cachemere
   </div>
   <div id="projectbrief">Modular Caching Library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecachemere.html">cachemere</a></li><li class="navelem"><a class="el" href="classcachemere_1_1Cache.html">Cache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classcachemere_1_1Cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread-safe memory-restricted cache.  
 <a href="classcachemere_1_1Cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache_8h_source.html">cache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2d1e3d485ade1baf341fdedbc45b238b"><td class="memItemLeft" align="right" valign="top"><a id="a2d1e3d485ade1baf341fdedbc45b238b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyInsertionPolicy</b> = InsertionPolicy&lt; Key, KeyHash, Value &gt;</td></tr>
<tr class="separator:a2d1e3d485ade1baf341fdedbc45b238b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a2d84d47233392802bdc9eb4d191c2a"><td class="memItemLeft" align="right" valign="top"><a id="a6a2d84d47233392802bdc9eb4d191c2a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyEvictionPolicy</b> = EvictionPolicy&lt; Key, KeyHash, Value &gt;</td></tr>
<tr class="separator:a6a2d84d47233392802bdc9eb4d191c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a811aa0fa69a0f92b34ae7b71956ce20b"><td class="memItemLeft" align="right" valign="top"><a id="a811aa0fa69a0f92b34ae7b71956ce20b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyConstraintPolicy</b> = ConstraintPolicy&lt; Key, KeyHash, Value &gt;</td></tr>
<tr class="separator:a811aa0fa69a0f92b34ae7b71956ce20b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaebdce19f69bdfa1c51d459fc850b3b"><td class="memItemLeft" align="right" valign="top"><a id="aeaebdce19f69bdfa1c51d459fc850b3b"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CacheType</b> = <a class="el" href="classcachemere_1_1Cache.html">Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;</td></tr>
<tr class="separator:aeaebdce19f69bdfa1c51d459fc850b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059b47bfd8bc705b977384cb4345d02c"><td class="memItemLeft" align="right" valign="top"><a id="a059b47bfd8bc705b977384cb4345d02c"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>LockGuard</b> = std::unique_lock&lt; std::recursive_mutex &gt;</td></tr>
<tr class="separator:a059b47bfd8bc705b977384cb4345d02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9792ddeece90042373786ed8d59ec1c"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:ab9792ddeece90042373786ed8d59ec1c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ab9792ddeece90042373786ed8d59ec1c">Cache</a> (Args... args)</td></tr>
<tr class="memdesc:ab9792ddeece90042373786ed8d59ec1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple constructor.  <a href="classcachemere_1_1Cache.html#ab9792ddeece90042373786ed8d59ec1c">More...</a><br /></td></tr>
<tr class="separator:ab9792ddeece90042373786ed8d59ec1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a42edf1ccf08d3ff0b3266ec2567bbf"><td class="memTemplParams" colspan="2">template&lt;typename C , typename... Args&gt; </td></tr>
<tr class="memitem:a5a42edf1ccf08d3ff0b3266ec2567bbf"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a5a42edf1ccf08d3ff0b3266ec2567bbf">Cache</a> (C &amp;collection, std::tuple&lt; Args... &gt; args)</td></tr>
<tr class="memdesc:a5a42edf1ccf08d3ff0b3266ec2567bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor to initialize the cache with a set of items.  <a href="classcachemere_1_1Cache.html#a5a42edf1ccf08d3ff0b3266ec2567bbf">More...</a><br /></td></tr>
<tr class="separator:a5a42edf1ccf08d3ff0b3266ec2567bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a377cfe394ef216b4f7b019e273f51592"><td class="memTemplParams" colspan="2">template&lt;typename KeyView &gt; </td></tr>
<tr class="memitem:a377cfe394ef216b4f7b019e273f51592"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a377cfe394ef216b4f7b019e273f51592">contains</a> (const KeyView &amp;key) const</td></tr>
<tr class="memdesc:a377cfe394ef216b4f7b019e273f51592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given key is stored in the cache.  <a href="classcachemere_1_1Cache.html#a377cfe394ef216b4f7b019e273f51592">More...</a><br /></td></tr>
<tr class="separator:a377cfe394ef216b4f7b019e273f51592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4ea31ad36af4973ecbe0a610612cee1"><td class="memTemplParams" colspan="2">template&lt;typename KeyView &gt; </td></tr>
<tr class="memitem:af4ea31ad36af4973ecbe0a610612cee1"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; Value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#af4ea31ad36af4973ecbe0a610612cee1">find</a> (const KeyView &amp;key) const</td></tr>
<tr class="memdesc:af4ea31ad36af4973ecbe0a610612cee1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a given key in cache returning the associated value when it exists.  <a href="classcachemere_1_1Cache.html#af4ea31ad36af4973ecbe0a610612cee1">More...</a><br /></td></tr>
<tr class="separator:af4ea31ad36af4973ecbe0a610612cee1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e1809c2bb23433c2551af93b3d00c6"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a77e1809c2bb23433c2551af93b3d00c6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a77e1809c2bb23433c2551af93b3d00c6">collect_into</a> (C &amp;container) const</td></tr>
<tr class="memdesc:a77e1809c2bb23433c2551af93b3d00c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the cache contents in the provided container.  <a href="classcachemere_1_1Cache.html#a77e1809c2bb23433c2551af93b3d00c6">More...</a><br /></td></tr>
<tr class="separator:a77e1809c2bb23433c2551af93b3d00c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4e99360ef97b1dd4d117940a2561c28"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ae4e99360ef97b1dd4d117940a2561c28">insert</a> (Key key, Value value)</td></tr>
<tr class="memdesc:ae4e99360ef97b1dd4d117940a2561c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair in the cache.  <a href="classcachemere_1_1Cache.html#ae4e99360ef97b1dd4d117940a2561c28">More...</a><br /></td></tr>
<tr class="separator:ae4e99360ef97b1dd4d117940a2561c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad399dd7b0ca51df9b12fcbf1718b8722"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ad399dd7b0ca51df9b12fcbf1718b8722">remove</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:ad399dd7b0ca51df9b12fcbf1718b8722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a key and its value from the cache.  <a href="classcachemere_1_1Cache.html#ad399dd7b0ca51df9b12fcbf1718b8722">More...</a><br /></td></tr>
<tr class="separator:ad399dd7b0ca51df9b12fcbf1718b8722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41370432fccda91666121927b36675c"><td class="memItemLeft" align="right" valign="top"><a id="ac41370432fccda91666121927b36675c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ac41370432fccda91666121927b36675c">clear</a> ()</td></tr>
<tr class="memdesc:ac41370432fccda91666121927b36675c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the cache contents. <br /></td></tr>
<tr class="separator:ac41370432fccda91666121927b36675c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f4bcc543b713c5c3ec829eb16ff291"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:ad5f4bcc543b713c5c3ec829eb16ff291"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ad5f4bcc543b713c5c3ec829eb16ff291">retain</a> (P predicate_fn)</td></tr>
<tr class="memdesc:ad5f4bcc543b713c5c3ec829eb16ff291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retain all objects matching a predicate.  <a href="classcachemere_1_1Cache.html#ad5f4bcc543b713c5c3ec829eb16ff291">More...</a><br /></td></tr>
<tr class="separator:ad5f4bcc543b713c5c3ec829eb16ff291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87ef925a7e1d2cc2f079d20f4109bd54"><td class="memTemplParams" colspan="2">template&lt;typename F &gt; </td></tr>
<tr class="memitem:a87ef925a7e1d2cc2f079d20f4109bd54"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a87ef925a7e1d2cc2f079d20f4109bd54">for_each</a> (F unary_function)</td></tr>
<tr class="memdesc:a87ef925a7e1d2cc2f079d20f4109bd54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function to all objects in cache.  <a href="classcachemere_1_1Cache.html#a87ef925a7e1d2cc2f079d20f4109bd54">More...</a><br /></td></tr>
<tr class="separator:a87ef925a7e1d2cc2f079d20f4109bd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8764c0d27fc80326247b2ae819298032"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a8764c0d27fc80326247b2ae819298032">swap</a> (<a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;other) noexcept</td></tr>
<tr class="memdesc:a8764c0d27fc80326247b2ae819298032"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the current cache with another cache of the same type.  <a href="classcachemere_1_1Cache.html#a8764c0d27fc80326247b2ae819298032">More...</a><br /></td></tr>
<tr class="separator:a8764c0d27fc80326247b2ae819298032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a514dc13c11a91a6d106d369291b7ef6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a514dc13c11a91a6d106d369291b7ef6e">number_of_items</a> () const</td></tr>
<tr class="memdesc:a514dc13c11a91a6d106d369291b7ef6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently stored in the cache.  <a href="classcachemere_1_1Cache.html#a514dc13c11a91a6d106d369291b7ef6e">More...</a><br /></td></tr>
<tr class="separator:a514dc13c11a91a6d106d369291b7ef6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d90e5c1c3dec9f1bfd6a002947bb0bd"><td class="memTemplParams" colspan="2">template&lt;typename... Args&gt; </td></tr>
<tr class="memitem:a9d90e5c1c3dec9f1bfd6a002947bb0bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a9d90e5c1c3dec9f1bfd6a002947bb0bd">update_constraint</a> (Args... args)</td></tr>
<tr class="memdesc:a9d90e5c1c3dec9f1bfd6a002947bb0bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update the cache constraint.  <a href="classcachemere_1_1Cache.html#a9d90e5c1c3dec9f1bfd6a002947bb0bd">More...</a><br /></td></tr>
<tr class="separator:a9d90e5c1c3dec9f1bfd6a002947bb0bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affaaa12058e4f3030906c7efe249eea5"><td class="memItemLeft" align="right" valign="top"><a id="affaaa12058e4f3030906c7efe249eea5"></a>
MyInsertionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#affaaa12058e4f3030906c7efe249eea5">insertion_policy</a> ()</td></tr>
<tr class="memdesc:affaaa12058e4f3030906c7efe249eea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the insertion policy used by the cache. <br /></td></tr>
<tr class="separator:affaaa12058e4f3030906c7efe249eea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d723b629f552d908c05651ccc5dc49"><td class="memItemLeft" align="right" valign="top"><a id="a53d723b629f552d908c05651ccc5dc49"></a>
const MyInsertionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a53d723b629f552d908c05651ccc5dc49">insertion_policy</a> () const</td></tr>
<tr class="memdesc:a53d723b629f552d908c05651ccc5dc49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the insertion policy used by the cache. <br /></td></tr>
<tr class="separator:a53d723b629f552d908c05651ccc5dc49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5db9ac3d0a6c53fe313d3aab22ab676e"><td class="memItemLeft" align="right" valign="top"><a id="a5db9ac3d0a6c53fe313d3aab22ab676e"></a>
MyEvictionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a5db9ac3d0a6c53fe313d3aab22ab676e">eviction_policy</a> ()</td></tr>
<tr class="memdesc:a5db9ac3d0a6c53fe313d3aab22ab676e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the eviction policy used by the cache. <br /></td></tr>
<tr class="separator:a5db9ac3d0a6c53fe313d3aab22ab676e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b12e6db45ffca59ede7475a4962da9"><td class="memItemLeft" align="right" valign="top"><a id="a26b12e6db45ffca59ede7475a4962da9"></a>
const MyEvictionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a26b12e6db45ffca59ede7475a4962da9">eviction_policy</a> () const</td></tr>
<tr class="memdesc:a26b12e6db45ffca59ede7475a4962da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the eviction policy used by the cache. <br /></td></tr>
<tr class="separator:a26b12e6db45ffca59ede7475a4962da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2469bba70d910e35e5ca86e4e7fab31d"><td class="memItemLeft" align="right" valign="top"><a id="a2469bba70d910e35e5ca86e4e7fab31d"></a>
MyConstraintPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a2469bba70d910e35e5ca86e4e7fab31d">constraint_policy</a> ()</td></tr>
<tr class="memdesc:a2469bba70d910e35e5ca86e4e7fab31d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the constraint policy used by the cache. <br /></td></tr>
<tr class="separator:a2469bba70d910e35e5ca86e4e7fab31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac00713c43714c2d295c7c2d8eb8ac9df"><td class="memItemLeft" align="right" valign="top"><a id="ac00713c43714c2d295c7c2d8eb8ac9df"></a>
const MyConstraintPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ac00713c43714c2d295c7c2d8eb8ac9df">constraint_policy</a> () const</td></tr>
<tr class="memdesc:ac00713c43714c2d295c7c2d8eb8ac9df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a const reference to the constraint policy used by the cache. <br /></td></tr>
<tr class="separator:ac00713c43714c2d295c7c2d8eb8ac9df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e07018b6325ee1c4967184b7e33d61a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a2e07018b6325ee1c4967184b7e33d61a">hit_rate</a> () const</td></tr>
<tr class="memdesc:a2e07018b6325ee1c4967184b7e33d61a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running hit rate of the cache.  <a href="classcachemere_1_1Cache.html#a2e07018b6325ee1c4967184b7e33d61a">More...</a><br /></td></tr>
<tr class="separator:a2e07018b6325ee1c4967184b7e33d61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb03f316f40980e9d2164cd30012bc5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#abcb03f316f40980e9d2164cd30012bc5">byte_hit_rate</a> () const</td></tr>
<tr class="memdesc:abcb03f316f40980e9d2164cd30012bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running byte hit rate of the cache, in bytes.  <a href="classcachemere_1_1Cache.html#abcb03f316f40980e9d2164cd30012bc5">More...</a><br /></td></tr>
<tr class="separator:abcb03f316f40980e9d2164cd30012bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6407fd0859e1145ed21e41781fe921ed"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a6407fd0859e1145ed21e41781fe921ed">statistics_window_size</a> () const</td></tr>
<tr class="memdesc:a6407fd0859e1145ed21e41781fe921ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the sliding window used for computing statistics.  <a href="classcachemere_1_1Cache.html#a6407fd0859e1145ed21e41781fe921ed">More...</a><br /></td></tr>
<tr class="separator:a6407fd0859e1145ed21e41781fe921ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ac1aceab46efcc8937b0a3e005a0bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#aa7ac1aceab46efcc8937b0a3e005a0bc">statistics_window_size</a> (uint32_t window_size)</td></tr>
<tr class="memdesc:aa7ac1aceab46efcc8937b0a3e005a0bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the size of the sliding window used for computing statistics.  <a href="classcachemere_1_1Cache.html#aa7ac1aceab46efcc8937b0a3e005a0bc">More...</a><br /></td></tr>
<tr class="separator:aa7ac1aceab46efcc8937b0a3e005a0bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab782db6a206da776dc32e6630f7590d5"><td class="memTemplParams" colspan="2"><a id="ab782db6a206da776dc32e6630f7590d5"></a>
template&lt;typename Coll , typename... Args&gt; </td></tr>
<tr class="memitem:ab782db6a206da776dc32e6630f7590d5"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Cache</b> (Coll &amp;collection, std::tuple&lt; Args... &gt; args)</td></tr>
<tr class="separator:ab782db6a206da776dc32e6630f7590d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094f8287fa2895ad38099b9e5c18e0c0"><td class="memTemplParams" colspan="2"><a id="a094f8287fa2895ad38099b9e5c18e0c0"></a>
template&lt;typename KeyView &gt; </td></tr>
<tr class="memitem:a094f8287fa2895ad38099b9e5c18e0c0"><td class="memTemplItemLeft" align="right" valign="top">std::optional&lt; V &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>find</b> (const KeyView &amp;key) const</td></tr>
<tr class="separator:a094f8287fa2895ad38099b9e5c18e0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0037f9321134fb57128bb99a211cd7b1"><td class="memTemplParams" colspan="2"><a id="a0037f9321134fb57128bb99a211cd7b1"></a>
template&lt;class Container &gt; </td></tr>
<tr class="memitem:a0037f9321134fb57128bb99a211cd7b1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>collect_into</b> (Container &amp;container) const</td></tr>
<tr class="separator:a0037f9321134fb57128bb99a211cd7b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7686fa3b3c20f0cf58b2451bae0d8f28"><td class="memTemplParams" colspan="2"><a id="a7686fa3b3c20f0cf58b2451bae0d8f28"></a>
template&lt;class Coll &gt; </td></tr>
<tr class="memitem:a7686fa3b3c20f0cf58b2451bae0d8f28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>import</b> (Coll &amp;collection)</td></tr>
<tr class="separator:a7686fa3b3c20f0cf58b2451bae0d8f28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:af253ce6d20d49a2e1042b9aa5e9ce1d6"><td class="memItemLeft" align="right" valign="top"><a id="af253ce6d20d49a2e1042b9aa5e9ce1d6"></a>
LockGuard&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> () const</td></tr>
<tr class="separator:af253ce6d20d49a2e1042b9aa5e9ce1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3811dc3e0f0723a5cd293edc727fcf4b"><td class="memItemLeft" align="right" valign="top"><a id="a3811dc3e0f0723a5cd293edc727fcf4b"></a>
LockGuard&#160;</td><td class="memItemRight" valign="bottom"><b>lock</b> (std::defer_lock_t defer_lock_tag) const</td></tr>
<tr class="separator:a3811dc3e0f0723a5cd293edc727fcf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab765af0f206c0e09333cae4e0f17aa82"><td class="memItemLeft" align="right" valign="top"><a id="ab765af0f206c0e09333cae4e0f17aa82"></a>
std::pair&lt; LockGuard, LockGuard &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lock_pair</b> (<a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;other) const</td></tr>
<tr class="separator:ab765af0f206c0e09333cae4e0f17aa82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedad1ef6621208f93b66f6f51e3a6c4c"><td class="memTemplParams" colspan="2"><a id="aedad1ef6621208f93b66f6f51e3a6c4c"></a>
template&lt;typename C &gt; </td></tr>
<tr class="memitem:aedad1ef6621208f93b66f6f51e3a6c4c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>import</b> (C &amp;collection)</td></tr>
<tr class="separator:aedad1ef6621208f93b66f6f51e3a6c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue = measurement::Size&lt;Value&gt;, typename MeasureKey = measurement::Size&lt;Key&gt;, typename KeyHash = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt;<br />
class cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;</h3>

<p>Thread-safe memory-restricted cache. </p>
<p>This class keeps the inserted items alive, and it handles the bulk of the Insert/Evict logic while respecting the size constraints.</p>
<p>Some logic is delegated to the insertion and eviction policies. For details, see the <a class="el" href="index.html">Main Page</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the key used for retrieving items. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the items stored in the cache. </td></tr>
    <tr><td class="paramname">InsertionPolicy</td><td>A template parameterized by <code>Key</code>, <code>KeyHash</code>, and <code>Value</code> implementing the insertion policy interface. </td></tr>
    <tr><td class="paramname">EvictionPolicy</td><td>A template parameterized by <code>Key</code> <code>KeyHash</code>, and <code>Value</code> implementing the eviction policy interface. </td></tr>
    <tr><td class="paramname">ConstraintPolicy</td><td>A template parameterized by <code>Key</code> <code>KeyHash</code>, and <code>Value</code> implementing the constraint policy interface. </td></tr>
    <tr><td class="paramname">MeasureValue</td><td>A functor returning the size of a cache value. </td></tr>
    <tr><td class="paramname">MeasureKey</td><td>A functor returning the size of a cache key. </td></tr>
    <tr><td class="paramname">KeyHash</td><td>A default-constructible callable type returning a hash of a key. Defaults to <code>absl::Hash&lt;Key&gt;</code>. </td></tr>
    <tr><td class="paramname">ThreadSafe</td><td>Whether to enable locking. When true, all cache operations will be protected by a lock. <code>true</code> by default. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9792ddeece90042373786ed8d59ec1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9792ddeece90042373786ed8d59ec1c">&#9670;&nbsp;</a></span>Cache() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue , typename MeasureKey , typename KeyHash , bool ThreadSafe&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;::<a class="el" href="classcachemere_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the constraint policy constructor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a42edf1ccf08d3ff0b3266ec2567bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a42edf1ccf08d3ff0b3266ec2567bbf">&#9670;&nbsp;</a></span>Cache() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, typename KeyHash  = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<div class="memtemplate">
template&lt;typename C , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;::<a class="el" href="classcachemere_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tuple&lt; Args... &gt;&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor to initialize the cache with a set of items. </p>
<p>Will insert items in order in the cache as long as the constraint is satisfied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collection</td><td>The collection to use to initialize the cache - must be a collection of pairs. </td></tr>
    <tr><td class="paramname">args</td><td>Tuple of arguments to forward to the constraint policy constructor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>Items that are imported from the collection are moved out of the container and left in an unspecified state. The container itself can be reused after clearing it. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abcb03f316f40980e9d2164cd30012bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb03f316f40980e9d2164cd30012bc5">&#9670;&nbsp;</a></span>byte_hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::byte_hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running byte hit rate of the cache, in bytes. </p>
<p>The byte hit rate represents the average amount of data saved by cache accesses. This is a very useful metric in applications where item load times scale linearly with item size, for instance in a web server. </p><dl class="section return"><dt>Returns</dt><dd>The byte hit rate, in bytes. </dd></dl>

</div>
</div>
<a id="a77e1809c2bb23433c2551af93b3d00c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e1809c2bb23433c2551af93b3d00c6">&#9670;&nbsp;</a></span>collect_into()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, typename KeyHash  = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<div class="memtemplate">
template&lt;typename C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;::collect_into </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the cache contents in the provided container. </p>
<p>The container should conform to either of the STL's interfaces for associative containers or for sequence containers. Uses <code>emplace_back</code> for sequence containers, and <code>emplace</code> for associative containers. If the provided container has <code>size()</code> and <code>reserve()</code> methods, <code>collect_into</code> will reserve the appropriate amount of space in the container before inserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container in which to insert the items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a377cfe394ef216b4f7b019e273f51592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a377cfe394ef216b4f7b019e273f51592">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<div class="memtemplate">
template&lt;typename KeyView &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const KeyView &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given key is stored in the cache. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyView</td><td>The type of the key used for retrieving items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose presence to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key is in cache. </dd></dl>

</div>
</div>
<a id="af4ea31ad36af4973ecbe0a610612cee1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4ea31ad36af4973ecbe0a610612cee1">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, typename KeyHash  = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<div class="memtemplate">
template&lt;typename KeyView &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;Value&gt; <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KeyView &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a given key in cache returning the associated value when it exists. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyView</td><td>The type of the key used for retrieving items. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if <code>key</code> is in cache, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a87ef925a7e1d2cc2f079d20f4109bd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87ef925a7e1d2cc2f079d20f4109bd54">&#9670;&nbsp;</a></span>for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<div class="memtemplate">
template&lt;class F &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::for_each </td>
          <td>(</td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>unary_function</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function to all objects in cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unary_function</td><td>The function to be applied to all items in cache. The function should have the signature <code>void fn(const Key&amp; key, const Value&amp; value)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2e07018b6325ee1c4967184b7e33d61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e07018b6325ee1c4967184b7e33d61a">&#9670;&nbsp;</a></span>hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running hit rate of the cache. </p>
<p>The hit rate is computed using a sliding window determined by the sliding window size passed to the constructor. </p><dl class="section return"><dt>Returns</dt><dd>The hit rate, as a fraction. </dd></dl>

</div>
</div>
<a id="ae4e99360ef97b1dd4d117940a2561c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4e99360ef97b1dd4d117940a2561c28">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, typename KeyHash  = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">Key&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Value&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a key/value pair in the cache. </p>
<p>If the key is new, the key/value pair will be inserted. If the key already exists, the provided value will overwrite the previous one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to associate with the value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the item was inserted in cache. </dd></dl>

</div>
</div>
<a id="a514dc13c11a91a6d106d369291b7ef6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a514dc13c11a91a6d106d369291b7ef6e">&#9670;&nbsp;</a></span>number_of_items()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::number_of_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently stored in the cache. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method acquires a mutual exclusion lock to secure the item count. Calling this excessively while the cache is under contention will be detrimental to performance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>How many items are in cache. </dd></dl>

</div>
</div>
<a id="ad399dd7b0ca51df9b12fcbf1718b8722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad399dd7b0ca51df9b12fcbf1718b8722">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class, class &gt; class InsertionPolicy, template&lt; class, class, class &gt; class EvictionPolicy, template&lt; class, class, class &gt; class ConstraintPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, typename KeyHash  = absl::Hash&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, ConstraintPolicy, MeasureValue, MeasureKey, KeyHash, ThreadSafe &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a key and its value from the cache. </p>
<p>If the key is not present in cache, no operation is taken. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove from the cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key was present in cache. </dd></dl>

</div>
</div>
<a id="ad5f4bcc543b713c5c3ec829eb16ff291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f4bcc543b713c5c3ec829eb16ff291">&#9670;&nbsp;</a></span>retain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::retain </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>predicate_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retain all objects matching a predicate. </p>
<p>Removes all items for which <code>predicate_fn</code> returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate_fn</td><td>The predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The type of the predicate function. The predicate should have the signature <code>bool fn(const Key&amp; key, const Value&amp; value)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6407fd0859e1145ed21e41781fe921ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6407fd0859e1145ed21e41781fe921ed">&#9670;&nbsp;</a></span>statistics_window_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::statistics_window_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the sliding window used for computing statistics. </p>
<dl class="section return"><dt>Returns</dt><dd>The size of the statistics sliding window. </dd></dl>

</div>
</div>
<a id="aa7ac1aceab46efcc8937b0a3e005a0bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ac1aceab46efcc8937b0a3e005a0bc">&#9670;&nbsp;</a></span>statistics_window_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::statistics_window_size </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>window_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the size of the sliding window used for computing statistics. </p>
<dl class="section warning"><dt>Warning</dt><dd>This will reset the access log, so cache accesses made prior to calling this will not be counted in the statistics. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">window_size</td><td>The desired statistics window size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8764c0d27fc80326247b2ae819298032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8764c0d27fc80326247b2ae819298032">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Swaps the current cache with another cache of the same type. </p>
<p>Calls <code>std::terminate</code> if the cache runs in thread-safe mode and an exception is thrown while locking its mutex. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The cache to swap this instance with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9d90e5c1c3dec9f1bfd6a002947bb0bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d90e5c1c3dec9f1bfd6a002947bb0bd">&#9670;&nbsp;</a></span>update_constraint()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class, class &gt; class I, template&lt; class, class, class &gt; class E, template&lt; class, class, class &gt; class C, class SV , class SK , class KH , bool TS&gt; </div>
<div class="memtemplate">
template&lt;typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, C, SV, SK, KH, TS &gt;::update_constraint </td>
          <td>(</td>
          <td class="paramtype">Args...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update the cache constraint. </p>
<p>Forwards the update to the constraint and evicts items from the cache until the constraint is satisfied. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td>Arguments to forward to the <code>Constraint::update()</code> . </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cachemere/<a class="el" href="cache_8h_source.html">cache.h</a></li>
<li>include/cachemere/<a class="el" href="cache_8hpp_source.html">cache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
