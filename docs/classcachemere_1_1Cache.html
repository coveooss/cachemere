<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Cachemere: cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey, ThreadSafe &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cachemere
   </div>
   <div id="projectbrief">Modular Caching Library for C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecachemere.html">cachemere</a></li><li class="navelem"><a class="el" href="classcachemere_1_1Cache.html">Cache</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classcachemere_1_1Cache-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey, ThreadSafe &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Thread-safe memory-restricted cache.  
 <a href="classcachemere_1_1Cache.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="cache_8h_source.html">cache.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1d881ea37e435fb05212fa6e448f5e50"><td class="memItemLeft" align="right" valign="top"><a id="a1d881ea37e435fb05212fa6e448f5e50"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyInsertionPolicy</b> = InsertionPolicy&lt; Key, Value &gt;</td></tr>
<tr class="separator:a1d881ea37e435fb05212fa6e448f5e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e0bdc3254977e106124a2d78096c1d"><td class="memItemLeft" align="right" valign="top"><a id="ab4e0bdc3254977e106124a2d78096c1d"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>MyEvictionPolicy</b> = EvictionPolicy&lt; Key, Value &gt;</td></tr>
<tr class="separator:ab4e0bdc3254977e106124a2d78096c1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19a7a3693bdabd256d70a444703d57"><td class="memItemLeft" align="right" valign="top"><a id="a6a19a7a3693bdabd256d70a444703d57"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>CacheType</b> = <a class="el" href="classcachemere_1_1Cache.html">Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey &gt;</td></tr>
<tr class="separator:a6a19a7a3693bdabd256d70a444703d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1006bf2c7d7dc2e4ff711568d47b54a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ab1006bf2c7d7dc2e4ff711568d47b54a">Cache</a> (size_t <a class="el" href="classcachemere_1_1Cache.html#a1b2ffb6cdc72ed03bb22a7d9157ac96c">maximum_size</a>, uint32_t statistics_window_size=1000)</td></tr>
<tr class="memdesc:ab1006bf2c7d7dc2e4ff711568d47b54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple constructor.  <a href="classcachemere_1_1Cache.html#ab1006bf2c7d7dc2e4ff711568d47b54a">More...</a><br /></td></tr>
<tr class="separator:ab1006bf2c7d7dc2e4ff711568d47b54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77cf1d98dd3a82f7dcca7bfac6944940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a77cf1d98dd3a82f7dcca7bfac6944940">contains</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a77cf1d98dd3a82f7dcca7bfac6944940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a given key is stored in the cache.  <a href="classcachemere_1_1Cache.html#a77cf1d98dd3a82f7dcca7bfac6944940">More...</a><br /></td></tr>
<tr class="separator:a77cf1d98dd3a82f7dcca7bfac6944940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a054b70f3b46e06c9efb2446aeb26adf4"><td class="memItemLeft" align="right" valign="top">std::optional&lt; Value &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a054b70f3b46e06c9efb2446aeb26adf4">find</a> (const Key &amp;key) const</td></tr>
<tr class="memdesc:a054b70f3b46e06c9efb2446aeb26adf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a given key in cache returning the associated value when it exists.  <a href="classcachemere_1_1Cache.html#a054b70f3b46e06c9efb2446aeb26adf4">More...</a><br /></td></tr>
<tr class="separator:a054b70f3b46e06c9efb2446aeb26adf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5463c76d8627f6c4920a1b09a7a277aa"><td class="memTemplParams" colspan="2">template&lt;typename C &gt; </td></tr>
<tr class="memitem:a5463c76d8627f6c4920a1b09a7a277aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a5463c76d8627f6c4920a1b09a7a277aa">collect_into</a> (C &amp;container) const</td></tr>
<tr class="memdesc:a5463c76d8627f6c4920a1b09a7a277aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the cache contents in the provided container.  <a href="classcachemere_1_1Cache.html#a5463c76d8627f6c4920a1b09a7a277aa">More...</a><br /></td></tr>
<tr class="separator:a5463c76d8627f6c4920a1b09a7a277aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32f6538036e48a53fc09dba64fc5e8ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a32f6538036e48a53fc09dba64fc5e8ad">insert</a> (const Key &amp;key, const Value &amp;value)</td></tr>
<tr class="memdesc:a32f6538036e48a53fc09dba64fc5e8ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert a key/value pair in the cache.  <a href="classcachemere_1_1Cache.html#a32f6538036e48a53fc09dba64fc5e8ad">More...</a><br /></td></tr>
<tr class="separator:a32f6538036e48a53fc09dba64fc5e8ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9f722affb48ec87cff3ba7c83f9ac7b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#aa9f722affb48ec87cff3ba7c83f9ac7b">remove</a> (const Key &amp;key)</td></tr>
<tr class="memdesc:aa9f722affb48ec87cff3ba7c83f9ac7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a key and its value from the cache.  <a href="classcachemere_1_1Cache.html#aa9f722affb48ec87cff3ba7c83f9ac7b">More...</a><br /></td></tr>
<tr class="separator:aa9f722affb48ec87cff3ba7c83f9ac7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d1be364fcf98e4ae7b3de88e1fed9a"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a02d1be364fcf98e4ae7b3de88e1fed9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a02d1be364fcf98e4ae7b3de88e1fed9a">retain</a> (P predicate_fn)</td></tr>
<tr class="memdesc:a02d1be364fcf98e4ae7b3de88e1fed9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retain all objects matching a predicate.  <a href="classcachemere_1_1Cache.html#a02d1be364fcf98e4ae7b3de88e1fed9a">More...</a><br /></td></tr>
<tr class="separator:a02d1be364fcf98e4ae7b3de88e1fed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c970feae46340e67211fee443c93ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a7c970feae46340e67211fee443c93ed8">swap</a> (<a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;other)</td></tr>
<tr class="memdesc:a7c970feae46340e67211fee443c93ed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swaps the current cache with another cache of the same type.  <a href="classcachemere_1_1Cache.html#a7c970feae46340e67211fee443c93ed8">More...</a><br /></td></tr>
<tr class="separator:a7c970feae46340e67211fee443c93ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae5d5865c872d9a5a7ba98b8a38ab7b2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#aae5d5865c872d9a5a7ba98b8a38ab7b2">number_of_items</a> () const</td></tr>
<tr class="memdesc:aae5d5865c872d9a5a7ba98b8a38ab7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items currently stored in the cache.  <a href="classcachemere_1_1Cache.html#aae5d5865c872d9a5a7ba98b8a38ab7b2">More...</a><br /></td></tr>
<tr class="separator:aae5d5865c872d9a5a7ba98b8a38ab7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdfa08d81e3b165b0465a08c8eeeecc8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#afdfa08d81e3b165b0465a08c8eeeecc8">size</a> () const</td></tr>
<tr class="memdesc:afdfa08d81e3b165b0465a08c8eeeecc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the amount of memory currently being used by cache items.  <a href="classcachemere_1_1Cache.html#afdfa08d81e3b165b0465a08c8eeeecc8">More...</a><br /></td></tr>
<tr class="separator:afdfa08d81e3b165b0465a08c8eeeecc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2ffb6cdc72ed03bb22a7d9157ac96c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a1b2ffb6cdc72ed03bb22a7d9157ac96c">maximum_size</a> () const</td></tr>
<tr class="memdesc:a1b2ffb6cdc72ed03bb22a7d9157ac96c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum amount of memory that can be used by the cache.  <a href="classcachemere_1_1Cache.html#a1b2ffb6cdc72ed03bb22a7d9157ac96c">More...</a><br /></td></tr>
<tr class="separator:a1b2ffb6cdc72ed03bb22a7d9157ac96c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c8beb59d70b800d9ba545ec1b2230e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a48c8beb59d70b800d9ba545ec1b2230e">set_maximum_size</a> (size_t max_size)</td></tr>
<tr class="memdesc:a48c8beb59d70b800d9ba545ec1b2230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum amount of memory that can be used by the cache.  <a href="classcachemere_1_1Cache.html#a48c8beb59d70b800d9ba545ec1b2230e">More...</a><br /></td></tr>
<tr class="separator:a48c8beb59d70b800d9ba545ec1b2230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7b34b985a815b00f9b2b0a60be129e"><td class="memItemLeft" align="right" valign="top"><a id="ada7b34b985a815b00f9b2b0a60be129e"></a>
MyInsertionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ada7b34b985a815b00f9b2b0a60be129e">insertion_policy</a> ()</td></tr>
<tr class="memdesc:ada7b34b985a815b00f9b2b0a60be129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the insertion policy used by the cache. <br /></td></tr>
<tr class="separator:ada7b34b985a815b00f9b2b0a60be129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0980e5de1e0878ef73a0034f05d1b721"><td class="memItemLeft" align="right" valign="top"><a id="a0980e5de1e0878ef73a0034f05d1b721"></a>
MyEvictionPolicy &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a0980e5de1e0878ef73a0034f05d1b721">eviction_policy</a> ()</td></tr>
<tr class="memdesc:a0980e5de1e0878ef73a0034f05d1b721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the eviction policy used by the cache. <br /></td></tr>
<tr class="separator:a0980e5de1e0878ef73a0034f05d1b721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ce17189a6823a87ff068e7b3a1d82a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#a39ce17189a6823a87ff068e7b3a1d82a">hit_rate</a> () const</td></tr>
<tr class="memdesc:a39ce17189a6823a87ff068e7b3a1d82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running hit rate of the cache.  <a href="classcachemere_1_1Cache.html#a39ce17189a6823a87ff068e7b3a1d82a">More...</a><br /></td></tr>
<tr class="separator:a39ce17189a6823a87ff068e7b3a1d82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49385469c4833bd05946fd7592bddad"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcachemere_1_1Cache.html#ad49385469c4833bd05946fd7592bddad">byte_hit_rate</a> () const</td></tr>
<tr class="memdesc:ad49385469c4833bd05946fd7592bddad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute and return the running byte hit rate of the cache, in bytes.  <a href="classcachemere_1_1Cache.html#ad49385469c4833bd05946fd7592bddad">More...</a><br /></td></tr>
<tr class="separator:ad49385469c4833bd05946fd7592bddad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue = measurement::Size&lt;Value&gt;, typename MeasureKey = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt;<br />
class cachemere::Cache&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;</h3>

<p>Thread-safe memory-restricted cache. </p>
<p>This class keeps the inserted items alive, and it handles the bulk of the Insert/Evict logic while respecting the size constraints.</p>
<p>Some logic is delegated to the insertion and eviction policies. For details, see the <a class="el" href="index.html">Main Page</a>. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Key</td><td>The type of the key used for retrieving items. </td></tr>
    <tr><td class="paramname">Value</td><td>The type of the items stored in the cache. </td></tr>
    <tr><td class="paramname">InsertionPolicy</td><td>A template parameterized by <code>Key</code> and <code>Value</code> implementing the insertion policy interface. </td></tr>
    <tr><td class="paramname">EvictionPolicy</td><td>A template parameterized by <code>Key</code> and <code>Value</code> implementing the eviction policy interface. </td></tr>
    <tr><td class="paramname">MeasureValue</td><td>A functor returning the size of a cache value. </td></tr>
    <tr><td class="paramname">MeasureKey</td><td>A functor returning the size of a cache key. </td></tr>
    <tr><td class="paramname">ThreadSafe</td><td>Whether to enable locking. When true, all cache operations will be protected by a lock. <code>true</code> by default. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1006bf2c7d7dc2e4ff711568d47b54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1006bf2c7d7dc2e4ff711568d47b54a">&#9670;&nbsp;</a></span>Cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue , typename MeasureKey , bool ThreadSafe&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::<a class="el" href="classcachemere_1_1Cache.html">Cache</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>statistics_window_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximum_size</td><td>The maximum amount memory to be used by the cache (in bytes). </td></tr>
    <tr><td class="paramname">statistics_window_size</td><td>The length of the cache history to be kept for statistics. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad49385469c4833bd05946fd7592bddad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49385469c4833bd05946fd7592bddad">&#9670;&nbsp;</a></span>byte_hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::byte_hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running byte hit rate of the cache, in bytes. </p>
<p>The byte hit rate represents the average amount of data saved by cache accesses. This is a very useful metric in applications where item load times scale linearly with item size, for instance in a web server. </p><dl class="section return"><dt>Returns</dt><dd>The byte hit rate, in bytes. </dd></dl>

</div>
</div>
<a id="a5463c76d8627f6c4920a1b09a7a277aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5463c76d8627f6c4920a1b09a7a277aa">&#9670;&nbsp;</a></span>collect_into()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<div class="memtemplate">
template&lt;class C &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::collect_into </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy the cache contents in the provided container. </p>
<p>The container should conform to either of the STL's interfaces for associative containers or for sequence containers. Uses <code>emplace_back</code> for sequence containers, and <code>emplace</code> for associative containers. If the provided container has <code><a class="el" href="classcachemere_1_1Cache.html#afdfa08d81e3b165b0465a08c8eeeecc8" title="Get the amount of memory currently being used by cache items.">size()</a></code> and <code>reserve()</code> methods, <code>collect_into</code> will reserve the appropriate amount of space in the container before inserting. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">container</td><td>The container in which to insert the items. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77cf1d98dd3a82f7dcca7bfac6944940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77cf1d98dd3a82f7dcca7bfac6944940">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::contains </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether a given key is stored in the cache. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key whose presence to test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key is in cache. </dd></dl>

</div>
</div>
<a id="a054b70f3b46e06c9efb2446aeb26adf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a054b70f3b46e06c9efb2446aeb26adf4">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; V &gt; <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a given key in cache returning the associated value when it exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to lookup. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value if <code>key</code> is in cache, <code>std::nullopt</code> otherwise. </dd></dl>

</div>
</div>
<a id="a39ce17189a6823a87ff068e7b3a1d82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ce17189a6823a87ff068e7b3a1d82a">&#9670;&nbsp;</a></span>hit_rate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::hit_rate</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute and return the running hit rate of the cache. </p>
<p>The hit rate is computed using a sliding window determined by the sliding window size passed to the constructor. </p><dl class="section return"><dt>Returns</dt><dd>The hit rate, as a fraction. </dd></dl>

</div>
</div>
<a id="a32f6538036e48a53fc09dba64fc5e8ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32f6538036e48a53fc09dba64fc5e8ad">&#9670;&nbsp;</a></span>insert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Value &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Insert a key/value pair in the cache. </p>
<p>If the key is new, the key/value pair will be inserted. If the key already exists, the provided value will overwrite the previous one. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to associate with the value. </td></tr>
    <tr><td class="paramname">value</td><td>The value to store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the item was inserted in cache. </dd></dl>

</div>
</div>
<a id="a1b2ffb6cdc72ed03bb22a7d9157ac96c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2ffb6cdc72ed03bb22a7d9157ac96c">&#9670;&nbsp;</a></span>maximum_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::maximum_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum amount of memory that can be used by the cache. </p>
<p>Once this size is reached, any future successful insertions will trigger evictions of one or more items. </p><dl class="section return"><dt>Returns</dt><dd>The maximum size, in bytes. </dd></dl>

</div>
</div>
<a id="aae5d5865c872d9a5a7ba98b8a38ab7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae5d5865c872d9a5a7ba98b8a38ab7b2">&#9670;&nbsp;</a></span>number_of_items()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::number_of_items</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items currently stored in the cache. </p>
<dl class="section warning"><dt>Warning</dt><dd>This method acquires a mutual exclusion lock to secure the item count. Calling this excessively while the cache is under contention will be detrimental to performance. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>How many items are in cache. </dd></dl>

</div>
</div>
<a id="aa9f722affb48ec87cff3ba7c83f9ac7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9f722affb48ec87cff3ba7c83f9ac7b">&#9670;&nbsp;</a></span>remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Key , typename Value , template&lt; class, class &gt; class InsertionPolicy, template&lt; class, class &gt; class EvictionPolicy, typename MeasureValue  = measurement::Size&lt;Value&gt;, typename MeasureKey  = measurement::Size&lt;Key&gt;, bool ThreadSafe = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; Key, Value, InsertionPolicy, EvictionPolicy, MeasureValue, MeasureKey, ThreadSafe &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const Key &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a key and its value from the cache. </p>
<p>If the key is not present in cache, no operation is taken. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key to remove from the cache. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the key was present in cache. </dd></dl>

</div>
</div>
<a id="a02d1be364fcf98e4ae7b3de88e1fed9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d1be364fcf98e4ae7b3de88e1fed9a">&#9670;&nbsp;</a></span>retain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<div class="memtemplate">
template&lt;class P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::retain </td>
          <td>(</td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>predicate_fn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retain all objects matching a predicate. </p>
<p>Removes all items for which <code>predicate_fn</code> returns false. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">predicate_fn</td><td>The predicate function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">P</td><td>The type of the predicate function. The predicate should have the signature <code>bool fn(const Key&amp; key, const Value&amp; value)</code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48c8beb59d70b800d9ba545ec1b2230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48c8beb59d70b800d9ba545ec1b2230e">&#9670;&nbsp;</a></span>set_maximum_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::set_maximum_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum amount of memory that can be used by the cache. </p>
<p>If the new maximum size is inferior to the maximum, the cache will resize itself and evict items until the new maximum is respected. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>The new maximum size, in bytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdfa08d81e3b165b0465a08c8eeeecc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfa08d81e3b165b0465a08c8eeeecc8">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the amount of memory currently being used by cache items. </p>
<p>This method returns the amount of memory used by the cache. For every item, the cache stores the key and its value, along with an additional copy of the key. This brings the total memory used by an item to <code>2 * MeasureKey(key) + MeasureValue(value)</code>. </p><dl class="section return"><dt>Returns</dt><dd>The current memory usage, in bytes. </dd></dl>

</div>
</div>
<a id="a7c970feae46340e67211fee443c93ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c970feae46340e67211fee443c93ed8">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class V , template&lt; class, class &gt; class I, template&lt; class, class &gt; class E, class SV , class SK , bool TS&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcachemere_1_1Cache.html">cachemere::Cache</a>&lt; K, V, I, E, SV, SK, TS &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcachemere_1_1Cache.html">CacheType</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swaps the current cache with another cache of the same type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The cache to swap this instance with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/cachemere/<a class="el" href="cache_8h_source.html">cache.h</a></li>
<li>include/cachemere/<a class="el" href="cache_8hpp_source.html">cache.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
